<link rel="import" href="../../vendor/polymer/polymer.html">
<link rel="import" href="../../vendor/the-graph/the-graph.html">
<!--
`the-graph` is the visual editor component of the Cubbles BDE

@demo demo/index.html
-->
<dom-module id="bde-graph">
  <template>
    <style>
      :host {
        position: relative;
        display: block;
      }

      #backdrop {
        position: absolute;
        top: 0; right: 0; bottom: 0; left: 0;
        z-index: 0;

        -webkit-box-sizing: content-box;
           -moz-box-sizing: content-box;
                box-sizing: content-box;
        -o-text-overflow: clip;
           text-overflow: clip;
        background: -webkit-linear-gradient(45deg, rgba(0,0,0,0.0980392) 25%, rgba(0,0,0,0) 25%, rgba(0,0,0,0) 75%, rgba(0,0,0,0.0980392) 75%, rgba(0,0,0,0.0980392) 0),
                    -webkit-linear-gradient(45deg, rgba(0,0,0,0.0980392) 25%, rgba(0,0,0,0) 25%, rgba(0,0,0,0) 75%, rgba(0,0,0,0.0980392) 75%, rgba(0,0,0,0.0980392) 0),
                    rgb(255, 255, 255);
        background: -moz-linear-gradient(45deg, rgba(0,0,0,0.0980392) 25%, rgba(0,0,0,0) 25%, rgba(0,0,0,0) 75%, rgba(0,0,0,0.0980392) 75%, rgba(0,0,0,0.0980392) 0),
                    -moz-linear-gradient(45deg, rgba(0,0,0,0.0980392) 25%, rgba(0,0,0,0) 25%, rgba(0,0,0,0) 75%, rgba(0,0,0,0.0980392) 75%, rgba(0,0,0,0.0980392) 0),
                    rgb(255, 255, 255);
        background: linear-gradient(45deg, rgba(0,0,0,0.0980392) 25%, rgba(0,0,0,0) 25%, rgba(0,0,0,0) 75%, rgba(0,0,0,0.0980392) 75%, rgba(0,0,0,0.0980392) 0),
                    linear-gradient(45deg, rgba(0,0,0,0.0980392) 25%, rgba(0,0,0,0) 25%, rgba(0,0,0,0) 75%, rgba(0,0,0,0.0980392) 75%, rgba(0,0,0,0.0980392) 0),
                    rgb(255, 255, 255);
        background-position: 0 0, 40px 40px;
        -webkit-background-origin: padding-box;
                background-origin: padding-box;
        -webkit-background-clip: border-box;
                background-clip: border-box;
        -webkit-background-size: 80px 80px;
                background-size: 80px 80px;

        @apply(--paper-font-display1);
        @apply(--layout-vertical);
        @apply(--layout-center-center)
      }
    </style>

    <div id="backdrop" hidden="[[ready]]">
      <p>Create a new compound component or load an existing one from the base.</p>
    </div>

    <the-graph id="graph"
      name="[[artifact.artifactId]]"
      graph="[[nofloGraph]]"
      menus="[[_menus]]"
      width="[[width]]" height="[[height]]"
      offset-x="[[offsetX]]" offset-y=[[offsetY]]
      pan="{{pan}}" scale="{{scale}}"
      autolayout="{{autolayout}}"
      theme="{{theme}}"
      selected-nodes="{{_selectedNodes}}"
      selected-edges="{{_selectedEdges}}"
      hidden="[[!ready]]"
      display-selection-group
      force-selection>
    </the-graph>

  </template>
  <script src="../../vendor/the-graph/build/noflo.js"></script>
  <script>
  (function() {
    "use strict";

    Polymer({
      is: 'bde-graph',

      hostAttributes: {
        'touch-action': 'none'
      },

      properties: {

        grid: {
          type: Number,
          value: 72
        },

        snap: {
          type: Number,
          value: 36
        },

        width: {
          type: Number,
          value: 800,
          notify: true,
          reflectToAttribute: true
        },

        height: {
          type: Number,
          value: 600,
          notify: true,
          reflectToAttribute: true
        },

        pan: {
          type: Array,
          value: function() {
            return [0,0];
          },
          notify: true
        },

        scale: {
          type: Number,
          value: 1,
          notify: true
        },

        offsetX: {
          type: Number,
          value: 0
        },

        offsetY: {
          type: Number,
          value: 0
        },

        autolayout: {
          type: Boolean,
          value: false
        },

        nofloGraph: {
          type: Object,
          notify: true
        },

        theme: {
          type: String,
          value: 'dark'
        },

        ready: {
          type: Boolean,
          value: false,
          notify: true
        },

        selectedMembers: {
          type: Array,
          notify: true
        },

        selectedConnections: {
          type: Array,
          notify: true
        },

        displaySelectionGroup: {
          type: Boolean,
          value: true
        },

        forceSelection: {
          type: Boolean,
          value: false
        },

        _graphHeight: {
          type: Number,
          value: 0
        },

        _graphWidth: {
          type: Number,
          value: 0
        },

        _plugins: {
          type: Object
        },

        _menus: {
          type: Object
        },

        _copyNodes: {
          type: Array
        },

        _selectedNodes: {
          type: Array
        },

        _selectedEdges: {
          type: Array
        }
      },

      observers: [
        '_selectedNodesChanged(_selectedNodes.splices)',
        '_selectedEdgesChanged(_selectedEdges.splices)',
        '_dimensionsChanged(width, height)',
        '_graphChanged(graph)',
        '_edgesChanged(nofloGraph.edges.splices)',
        '_inportsChanged(nofloGraph.inports)',
        '_outportsChanged(nofloGraph.outports)',
        '_nodesChanged(nofloGraph.nodes.splices)'
      ],

      listeners: {
        'graph.edges': 'handleEdges',
        'graph.nodes': 'handleNodes'
      },

      attached: function() {

        // Refer _getMenuDef to the graph
        this.$.graph.getMenuDef = this._getMenuDef.bind(this);

        var pasteAction = function(graph, itemKey, item) {
          var pasted = TheGraph.Clipboard.paste(graph);
          this.set('_selectedNodes', pasted.nodes);
          this.set('_selectedEdges', []);
        }.bind(this);

        var pasteMenu = {
          icon: 'paste',
          iconLabel: 'paste',
          action: pasteAction
        };

        // Default context menu defs
        var nodeActions = {

          delete: function(graph, itemKey, item) {
            graph.removeNode(itemKey);
            // Remove selection
            var newSelection = this._selectedNodes
              .filter(function(selected) { return (selected !== item) });
            this.set('_selectedNodes', newSelection);
          }.bind(this),

          copy: function(graph, itemKey, item) {
            TheGraph.Clipboard.copy(graph, [itemKey]);
          }
        }, edgeActions = {

          delete: function(graph, itemKey, item) {
            graph.removeEdge(item.from.node, item.from.port, item.to.node, item.to.port);
            // Remove selection
            var newSelection = this._selectedEdges
              .filter(function(selected) { return (selected !== item) });
            this.set('_selectedEdges', newSelection);
          }.bind(this)
        };

        this.set('_menus', {

          main: {
            icon: 'sitemap',
            e4: pasteMenu
          },

          edge: {
            actions: edgeActions,
            icon: 'long-arrow-right',
            s4: {
              icon: 'trash-o',
              iconLabel: 'delete',
              action: edgeActions.delete
            }
          },

          node: {
            actions: nodeActions,
            s4: {
              icon: 'trash-o',
              iconLabel: 'delete',
              action: nodeActions.delete
            },
            w4: {
              icon: 'copy',
              iconLabel: 'copy',
              action: nodeActions.copy
            }
          },

          nodeInport: {
            w4: {
              icon: 'sign-in',
              iconLabel: 'export',
              action: function(graph, itemKey, item) {
                var pub = item.port;

                if (pub === 'start') {
                  pub = 'start1';
                }

                if (pub === 'graph') {
                  pub = 'graph1';
                }

                var count = 0;
                // Make sure public is unique
                while (graph.inports[pub]) {
                  count++;
                  pub = item.port + count;
                }
                var priNode = graph.getNode(item.process);
                var metadata = {x:priNode.metadata.x-144, y:priNode.metadata.y};
                graph.addInport(pub, item.process, item.port, metadata);
              }
            }
          },

          nodeOutport: {
            e4: {
              icon: 'sign-out',
              iconLabel: 'export',
              action: function (graph, itemKey, item) {
                var pub = item.port;
                var count = 0;
                // Make sure public is unique
                while (graph.outports[pub]) {
                  count++;
                  pub = item.port + count;
                }
                var priNode = graph.getNode(item.process);
                var metadata = {x:priNode.metadata.x+144, y:priNode.metadata.y};
                graph.addOutport(pub, item.process, item.port, metadata);
              }
            }
          },

          graphInport: {
            icon: 'sign-in',
            iconColor: 2,
            n4: {
              label: 'inport'
            },
            s4: {
              icon: 'trash-o',
              iconLabel: 'delete',
              action: function (graph, itemKey, item) {
                graph.removeInport(itemKey);
              }
            }
          },

          graphOutport: {
            icon: 'sign-out',
            iconColor: 5,
            n4: {
              label: 'outport'
            },
            s4: {
              icon: 'trash-o',
              iconLabel: 'delete',
              action: function (graph, itemKey, item) {
                graph.removeOutport(itemKey);
              }
            }
          },

          group: {
            icon: 'th',
            s4: {
              icon: 'trash-o',
              iconLabel: 'ungroup',
              action: function (graph, itemKey, item) {
                graph.removeGroup(itemKey);
              }
            },
            // TODO copy group?
            e4: pasteMenu
          },

          selection: {
            icon: 'th',
            w4: {
              icon: 'copy',
              iconLabel: 'copy',
              action: function (graph, itemKey, item) {
                TheGraph.Clipboard.copy(graph, item.nodes);
              }
            },
            e4: pasteMenu
          }
        });
      },

      detached: function() {
        Object.keys(this._plugins).forEach(function(name) {
          this._plugins[name].unregister(this);
          delete this._plugins[name];
        }, this);
      },

      addPlugin: function(name, plugin) {
        this.set('_plugins.' + name, plugin);
        plugin.register(this);
      },

      addMember: function(member) {
        this.$.graph.addNode(
          member.memberId,
          member.componentId,
          { x: 0, y: 0, label: member.displayName || member.memberId }
        );
      },

      addMenu: function(type, options) {
        // options: icon, label
        this.set('_menus.' + type, options);
      },

      addMenuCallback: function(type, callback) {
        if (!this._menus[type]) { return; }

        this.set('_menus.' + type + '.callback', callback);
      },

      addMenuAction: function(type, direction, options) {
        if (!this._menus[type]) {
          this.set('_menus.' + type, {});
        }

        this.set('_menus.' + type + '.' + direction, options);
      },

      handleEdges: function() {
        // @TODO (fdu): handle selection here...
      },

      handleNodes: function() {
        // @TODO (fdu): handle selection here...
      },

      focusMember: function(member) {
        var node = this._nodeForMember(member);
        this.$.graph.focusNode(node);
      },

      updateIcon: function(nodeId, icon) {
        this.$.graph.updateIcon(nodeId, icon);
      },

      registerComponent: function(definition, generated) {
        this.$.graph.registerComponent(definition, generated);
      },

      rerender: function() {
        this.$.graph.rerender();
      },

      triggerAutolayout: function() {
        this.$.graph.triggerAutolayout();
      },

      triggerFit: function() {
        this.$.graph.triggerFit();
      },

      _buildInitialLibrary: function(nofloGraph) {
        nofloGraph.nodes.forEach(function(node) {
          var component = {
            name: node.component,
            icon: 'cog',
            description: '',
            inports: [],
            outports: []
          };

          Object.keys(nofloGraph.inports).forEach(function(pub) {
            var exported = nofloGraph.inports[pub];
            if (exported.process === node.id) {
              for (var i = 0; i < component.inports.length; i++) {
                if (component.inports[i].name === exported.port) {
                  return;
                }
              }
              component.inports.push({
                name: exported.port,
                type: 'all'
              });
            }
          });

          Object.keys(nofloGraph.outports).forEach(function(pub) {
            var exported = nofloGraph.outports[pub];
            if (exported.process === node.id) {
              for (var i = 0; i < component.outports.length; i++) {
                if (component.outports[i].name === exported.port) {
                  return;
                }
              }
              component.outports.push({
                name: exported.port,
                type: 'all'
              });
            }
          });

          nofloGraph.initializers.forEach(function(iip) {
            if (iip.to.node === node.id) {
              for (var i = 0; i < component.inports.length; i++) {
                if (component.inports[i].name === iip.to.port) {
                  return;
                }
              }
              component.inports.push({
                name: iip.to.port,
                type: 'all'
              });
            }
          });

          nofloGraph.edges.forEach(function(edge) {
            var i;
            if (edge.from.node === node.id) {
              for (i = 0; i < component.outports.length; i++) {
                if (component.outports[i].name === edge.from.port) {
                  return;
                }
              }
              component.outports.push({
                name: edge.from.port,
                type: 'all'
              });
            }
            if (edge.to.node === node.id) {
              for (i = 0; i < component.inports.length; i++) {
                if (component.inports[i].name === edge.to.port) {
                  return;
                }
              }
              component.inports.push({
                name: edge.to.port,
                type: 'all'
              });
            }
          });
          this.registerComponent(component, true);
        }.bind(this));
      },

      _edgesChanged: function(changeRecord) {
        if (!changeRecord) { return; }

        changeRecord.indexSplices.forEach(function(s) {
          s.removed.forEach(function(edge) {
            this.fire('bde-graph-edge-removed', edge);
          }, this);
          for (var i = 0; i < s.addedCount; i++) {
            var index = s.index + i;
            var edge = s.object[index];
            this.fire('bde-graph-edge-added', edge);
          }
        }, this);
      },

      _inportsChanged: function(newInports, oldInports) {
        if (!newInports) { return; }

        Object.keys(newInports).forEach(function(key) {
          if (!oldInports || !oldInports[key]) {
            this.fire('bde-graph-inport-added', { key: key, port: newInports[key] });
          }
        }, this);
        Object.keys(oldInports || {}).forEach(function(key) {
          if (!newInports[key]) {
            this.fire('bde-graph-inport-removed', { key: key, port: oldInports[key] });
          }
        }, this);
      },

      _outportsChanged: function(newOutports, oldOutports) {
        if (!newOutports) { return; }

        Object.keys(newOutports).forEach(function(key) {
          if (!oldOutports[key]) {
            this.fire('bde-graph-outport-added', { key: key, port: newOutports[key] });
          }
        }, this);
        Object.keys(oldOutports || {}).forEach(function(key) {
          if (!newOutports[key]) {
            this.fire('bde-graph-outport-removed', { key: key, port: oldOutports[key] });
          }
        }, this);
      },

      _nodesChanged: function(changeRecord) {
        if (!changeRecord) { return; }

        changeRecord.indexSplices.forEach(function(s) {
          s.removed.forEach(function(node) {
            this.fire('bde-graph-node-removed', node);
          }, this);
          for (var i = 0; i < s.addedCount; i++) {
            var index = s.index + i;
            var node = s.object[index];
            this.fire('bde-graph-node-added', node);
          }
        }, this);
      },


      _dimensionsChanged: function(width, height) {
        this.style.width = width + 'px';
        this.style.height = height + 'px';
      },

      _getMenuDef: function(options) {
        // Options: type, graph, itemKey, item
        if (options.type && this._menus[options.type]) {
          var defaultMenu = this._menus[options.type];
          if (defaultMenu.callback) {
            return defaultMenu.callback(defaultMenu, options);
          }
          return defaultMenu;
        }
      },

      _graphChanged: function() {
        if (typeof this.graph.addNode === 'function') {
          this._buildInitialLibrary(this.graph);
          this.set('nofloGraph', this.graph);
          return;
        }

        var noflo;
        if ('noflo' in window) {
          noflo = window.noflo;
        }
        if (!noflo && 'require' in window) {
          noflo = require('noflo');
        }
        if (!noflo) {
          throw Error("Missing noflo dependency! Should be built with Component.io or Browserify to require it.");
        }

        noflo.graph.loadJSON(this.graph, function(ignore, nofloGraph) {
          this._buildInitialLibrary(nofloGraph);
          this.set('nofloGraph', nofloGraph);
          this.ready = true;
          this.fire('bde-graph-initialized', this);
        }.bind(this));
      },

      _libraryRefresh: function() {
        this.$.graph.debounceLibraryRefresh();
      },

      _nodeForMember: function(member) {
        var node;
        if (this._nodes[member.memberId]) {
          node = this._nodes[member.memberId];
        }

        return node;
      },

      _selectedEdgesChanged: function(changeRecord) {

      },

      _selectedNodesChanged: function(changeRecord) {

      }
    });
  })();
  </script>
</dom-module>
