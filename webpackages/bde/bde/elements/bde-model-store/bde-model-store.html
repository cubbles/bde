<script src="../../vendor/lodash/lodash.min.js"></script>

<!--
# Deprecated

This element is deprecated and will be removed or replaced in the next version.

# bde-model-store

Custom Polymer element for the BDE application

`bde-model-store` for storing the model-data for the Cubixx-Components in the application.

Other application elements can listen to the respective model-change-events of the bde-model-store's properties.

### Notes
The element has no view.

@class bde-model-store
@homepage https://pmt.incowia.de/webble/blob/?f=public/elements/bde-model-store/bde-model-store.html&r=client/bde.git&h=master
-->
<dom-module id="bde-model-store">

    <script>
    (function () {
        'use strict';

        Polymer({
            is: 'bde-model-store',
            properties: {
                /**
                 * Id of the compound component [groupid+name+version+suffix]
                 *
                 * @property compoundId
                 * @type string
                 */
                compoundId: {
                    type: String,
                },
                /**
                 * Array of all internal connections of the compound component
                 *
                 * @property connections
                 * @type array
                 * @default []
                 */
                connections: {
                    type: Array,
                    notify: true,
                    value : []
                },
                /**
                 * DisplayName for the compound component, could be edited by composer
                 *
                 * @property displayName
                 * @type string
                 */
                displayName: {
                    type: String,
                    observer: 'displayNameChanged'
                },

                id: {
                    observer: 'idChanged'
                },

                name: {
                    observer: 'nameChanged'
                },
                /**
                 * Initializers for the compound component, e.g. default values of slots
                 *
                 * @property initializers
                 * @type array
                 * @default []
                 */
                initializers: {
                    type: Array,
                    notify: true,
                    value : function() {
                      return [];
                    }
                },
                /**
                 * External inslots, exposed to other components
                 *
                 * @property inslots
                 * @type object
                 * @default {}
                 */
                inslots: {
                    type: Array,
                    notify: true,
                    value: function() {
                      return [];
                    }
                },
                /**
                 * External outslots exposed to other components
                 *
                 * @property outslots
                 * @type array
                 * @default {}
                 */
                outslots: {
                    type: Array,
                    notify: true,
                    value: function() {
                        return [];
                    }
                },

                memberId: {
                    type: String,
                },

                /**
                 * members
                 * @property members
                 * @type object
                 * @default {}
                 *
                 * */
                members: {
                    type: Array,
                    notify: true,
                    value: function() {
                        return [];
                    }
                },

                selectedNodes: {
                    type: Array
                },

                /**
                 * Type for the compound component, this should be fixed to 'compound'
                 *
                 * @property type
                 * @type string
                 * @default 'compound'
                 */
                type: {
                    type: String,
                    notify: true,
                    value: 'compound',
                    observer: 'typeChanged'
                },
                /**
                 * Webpackage object describes the current webpackage metadata, from user input
                 *
                 * @property webpackage
                 * @type object
                 * @default {}
                 */
                webpackage: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                }
            },

            observers: [
                'selectedNodesChanged(selectedNodes.splices)'
            ],

            /**
             * This callback is fired when the model store is attached to the DOM
             */
            attached: function() {

                // Attach global event listeners
                document.addEventListener('docInput.submit', e => this.addWebpackage(e.detail.data));

                //addConnection: function(fromMember, fromSlot, toMember, toSlot, metadata)
                document.addEventListener('graph.addEdge', e => this.addConnection(e.detail.connection.from.node, e.detail.connection.from.port, e.detail.connection.to.node, e.detail.connection.to.port, e.detail.connection.metadata) )
                //removeConnection: function(fromMember, fromSlot, toMember, toSlot, metadata)
                document.addEventListener('graph.removeEdge', e => {
                    var connection = e.detail.connection;
                    this.removeConnection(this.connections.find(c => {
                        return c.source.memberIndex == connection.from.node &&
                               c.source.slot == connection.from.port &&
                               c.target.memberIndex == connection.to.node &&
                               c.target.slot == connection.to.port;
                    }));
                });
                // removeMember: function(id)
                document.addEventListener('graph.removeNode', e => this.removeMember(e.detail.node.id) )
                // addInslot: function(name, type, memberId, portName, metadata)
                // TODO (ene) : problem with duplication of ports on creation
                document.addEventListener('graph.addInport', e => this.addInslot(e.detail.Inport.name, null, e.detail.Inport.member, e.detail.Inport.inslot, e.detail.Inport.metadata))
                // removeInslot: function(name)
                document.addEventListener('graph.removeInport', e => this.removeInslot(e.detail.Inport))
                // addOutslot: function(name, type, memberId, portName, metadata)
                // TODO (ene) : problem with duplication of ports on creation
                document.addEventListener('graph.addOutport', e => this.addOutslot(e.detail.Outport.name, null, e.detail.Outport.member, e.detail.Outport.outslot, e.detail.Outport.metadata) )
                // removeOutslot: function(name)
                document.addEventListener('graph.removeOutport', e => this.removeOutslot(e.detail.Outport) )


            },

            /**
             * Adds webpackage metadata to the respective properties
             *
             * @method addWebpackage
             * @param {object} webpackage receiving metadata from user input
             */
            addWebpackage: function(webpackage) {
                this.webpackage = webpackage;
                this.name = webpackage.name;
                this.displayName = webpackage.name;
                // TODO:150 (ene): which properties make up the model-store.id ???
                this.id = webpackage.groupid + '.' + webpackage.name + '-' + webpackage.version;
                return this;
            },

            /**
             * Retrieves a member by its local id
             *
             * @method getMember
             * @param  {string} id local id of member
             * @return {object|null}
             */
            getMember: function(id) {

                return this.members.find(m => m.id === id);

            },

            /**
             * Retrieve a list of members by their componentId
             *
             * @method getMembers
             * @param  {string} cid [cubixx id of the member]
             * @return {array}
             */
            getMembers: function(componentId) {

                return this.members.filter(m => m.cid === componentId);

            },

            /**
             * Add a member
             *
             * @method addMember
             * @param {string} id      id of added component
             * @param {array} inslots  inslots of added component
             * @param {array} outslots outslots of added component
             * @param {array} metadata metadata of added component, e.g. position x,y, defaultValue
             */
            addMember: function(compoundId, id, inslots, outslots, metadata) {

                if (id.match(/\./)) {
                   throw new TypeError("id must not contain a dot `.`");
                }

                // Save original id as label
                metadata.label = id;

                var newMember = {
                    id: id + "_" + Math.random().toString(36).substring(7), // Create a unique id
                    compoundId: compoundId,
                    inslots: inslots,
                    outslots: outslots,
                    metadata: metadata
                };

                this.push('members', newMember);
                // TODO
                //this.fire('store.addMember', { member: newMember });

                return newMember;

            },

            /**
            * copy a member
            *
            * @method copyMember
            * @param {string} compoundId      id of added component
            * @param {string} id              id of added component
            */
            copyMember: function(compoundId) {

                return JSON.parse(JSON.stringify(this.getMembers(componentId)[0]));

            },

            /**
             * Remove a member
             *
             * @method removeMember
             * @param  {string} id local id of memter
             * @return {[type]}    [description]
             */
            removeMember: function(id) {

                var member = this.getMember(id);

                if (!member) return;

                // Remove related connections
                this.connections.filter(s => s.target.memberIndex == id || s.source.memberIndex == id).forEach(this.removeConnection);

                // Remove related inslots
                this.connections.filter(s => s.target.memberIndex == id && undefined == s.source.memberIndex).forEach(this.removeInslot);

                // Remove related outslots
                this.connections.filter(s => s.source.memberIndex == id && undefined == s.target.memberIndex).forEach(this.removeOutslot);

                // Remove initializers
                this.initializers.filter(i => i.to.member === id).forEach(this.removeInitializer);

                this.splice('members', this.members.indexOf(member), 1);
                this.fire('store.removeMember', { id: id, member: member });
                return this;

            },

            selectedNodesChanged: function () {
                this.members.forEach( (member, id) => {
                    this.set('members.' + id + '.selected', !!this.selectedNodes.find( n => n.id == member.id));
                });
            },

            /**
             * Set member metadata
             *
             * @method setMemberMetadata
             * @param {string} id       local id of member
             * @param {array} metadata  the respective metadata array
             */
            setMemberMetadata: function(id, metadata) {

                var member = this.getMember(id);

                if (!member || !metadata) return;

                var beforeValue = JSON.parse(JSON.stringify(metadata));
                var newValue = {};

                var item;
                for (item in metadata) {
                    if (metadata.hasOwnProperty(item) && metadata[item]) {
                        newValue[item] = metadata[item];
                    }
                }

                this.set('members.' + id + '.metadata', newValue);
                this.fire('store.changeMember', {
                    'newVal': member,
                    'oldVal': beforeValue
                });

                return this;
            },

            /**
             * Add external inslot
             *
             * @method addInslot
             * @param {string} name name of the slot
             * @param {string} type type of the slot, e.g. number, string,...
             * @param {object} metadata metadata of the slot, e.g  default values
             * @returns {addInslot}
             * @throws {Error} If portName on member is unknown
             */
            addInslot: function(name, type, memberId, portName, metadata) {

                metadata = metadata || {};

                if (!name) return;

                if (!this.getMember(memberId).inslots.find(s => s.name === portName)) {
                    throw new Error("Member `" + memberId + "` does not have a slot named `" + portName + "`.");
                }

                // Create unique portNames
                var originalName = portName;
                var count = this.inslots.reduce((sum, s) => sum + (s.name == portName), 0);
                if (count > 0) {
                    portName += "_" + count;
                }

                var slot = {
                    'name': name,
                    'originalName': originalName,
                    'type': type,
                    'metadata': metadata
                };
                this.push('inslots', slot);

                this.addConnection(null, name, memberId, portName, metadata);
                this.fire('store.addInslot', {
                    slot: slot,
                    member: memberId,
                    port: portName,
                    metadata: metadata
                });

                return this;

            },

            /**
             * Remove slot from inslot-array
             * @param {string} name name of the slot
             * @returns {removeInslot}
             */
            removeInslot: function(slotName) {

                var slot = this.inslots.find(s => s.name == slotName);

                // Remove slot
                this.splice('inslots', this.inslots.indexOf(slot), 1);

                // Remove related connections
                this.removeConnection(this.connections.find(c => c.source.slot === slotName && c.source.memberIndex == null));

                this.fire('store.removeInslot', { slot: slot });

                return this;

            },

            /**
             * Outslot with a connection related to a member
             * Add slot to output-array
             *
             * @method addOutslot
             * @param {string} name name of the slot
             * @param {string} type type of the slot, e.g. number, string,...
             * @param {object} metadata metadata of the slot, e.g  default values
             * @returns {addOutslot}
             */
            addOutslot: function(name, type, memberId, portName, metadata) {

                metadata = metadata || {};

                if (!name) return;

                if (!this.getMember(memberId).outslots.find(s => s.name === portName)) {
                    throw new Error("Member `" + memberId + "` does not have a slot named `" + portName + "`.");
                }

                // Create unique portNames
                var originalName = portName;
                var count = this.outslots.reduce((sum, s) => sum + (s.name == portName), 0);
                if (count > 0) {
                    portName += "_" + count;
                }

                var slot = {
                    'name': name,
                    'originalName': originalName,
                    'type': type,
                    'metadata': metadata
                };
                this.push('outslots', slot);

                this.addConnection(memberId, portName, null, name, metadata);
                this.fire('store.addOutslot', {
                    slot: slot,
                    member: memberId,
                    port: portName,
                    metadata: metadata
                });

                return this;

            },

            /**
             * Removes slot from outslot-array
             *
             * @method removeOutslot
             * @param {string} name name of the slot
             * @returns {removeOutslot}
             */
            removeOutslot: function (slotName) {

                var slot = this.outslots.find(s => s.name == slotName);

                // Remove slot
                this.splice('outslots', this.outslots.indexOf(slot), 1);

                // Remove related connections
                this.removeConnection(this.connections.find(c => c.target.slot === slotName && c.target.memberIndex == null));

                this.fire('store.removeOutslot', { slot: slot });

                return this;

            },

            // (ene) TODO: document addInitializer properly
            /**
             * Adds an initializer
             *
             * @method addInitializer
             * @param member
             * @param slot
             * @param data
             * @param metadata
             * @returns {addInitializer}
             */
            addInitializer: function(member, slot, data, metadata) {

                if (-1 == this.members.indexOf(member) ||
                    -1 == member.inslots.indexOf(slot)) {
                    return;
                }

                var initializer = {
                    member: member,
                    slot: slot,
                    data: data || null,
                    metadata: metadata || {}
                };
                this.push('initializers', initializer);
                this.fire('store.addInitializer', { initializer: initializer });
                return this;

            },

            // (ene) TODO: document removeInitializer properly
            /**
             * Removes an Initializer
             *
             * @method removeInitializer
             * @param member
             * @param slot
             * @returns {removeInitializer}
             */
            removeInitializer: function(initializer) {

                this.splice('initializers', this.initializers.indexOf(initializer), 1);
                this.fire('store.removeInitializer', { initializer: initializer });
                return this;

            },

            /**
             * Adds connection to connections array
             *
             * @param {String} fromMemberId Id of the source member
             * @param {String} fromSlotName Name of the source slot
             * @param {String} toMemberId   Id of the target member
             * @param {String} toSlotName   Name of the target slot
             * @param {Object} metadata     Additional info (optional)
             * @return {Array}              Current connections array
             */
            addConnection: function(fromMemberId, fromSlotName, toMemberId, toSlotName, metadata) {

                var fromMember = this.getMember(fromMemberId);
                var toMember = this.getMember(toMemberId);

                metadata = metadata || {};

                // Check for unknown members or self-reference
                if (!fromMember && !toMember || (fromMemberId == toMemberId)) {
                    return;
                }

                // Check for unknown slots
                if (fromMember && !fromMember.outslots.find( s => s.slotId == fromSlotName) ||
                    toMember && !toMember.inslots.find(s => s.slotId == toSlotName)) {
                    return;
                }

                // Check for duplicate connections
                if (this.connections.find(c => c.source.memberIndex == fromMemberId && c.source.slot == fromSlotName && c.target.memberIndex == toMemberId && c.target.slot == toSlotName)) {
                    console.warn("Connection `%s:%s` => `%s:%s` allready exists.", fromMemberId, fromSlotName, toMemberId, toSlotName);
                    return;
                }

                var connection = {
                    'source': { 'memberIndex': fromMemberId, 'slot': fromSlotName },
                    'target': { 'memberIndex': toMemberId, 'slot': toSlotName }
                };

                this.push('connections', connection);
                this.fire('store.addConnection', { connection: connection });

                return this.connections;

            },

            /**
             * Removes connection from connections-array
             *
             * @method removeConnection
             * @param fromMember
             * @param fromSlot
             * @param toMember
             * @param toSlot
             * @returns {removeConnection}
             */
            removeConnection: function(connection) {

                if (!connection) {
                    console.warn('Trying to remove non-existent connection.');
                    return;
                }

                this.splice('connections', this.connections.indexOf(connection), 1);
                this.fire('store.removeConnection', { connection: connection });

            },

            /**
             * @event idChanged
             * @param oldValue
             * @param newValue
             */
            idChanged: function(newValue, oldValue) {
                this.fire('propertyChanged', {
                    prop: 'id',
                    oldValue: oldValue,
                    newValue: newValue
                });
            },

            /**
             * @event nameChanged
             * @param oldValue
             * @param newValue
             */
            nameChanged: function(newValue, oldValue) {
                this.fire('propertyChanged', {
                    prop: 'name',
                    oldValue: oldValue,
                    newValue: newValue
                });
            },

            /**
             * @event typeChanged
             * @param oldValue
             * @param newValue
             */
            typeChanged: function(newValue, oldValue) {
                this.fire('propertyChanged', {
                    prop: 'type',
                    oldValue: oldValue,
                    newValue: newValue
                });
            },

            /**
             * @event displayNameChanged
             * @param oldValue
             * @param newValue
             */
            displayNameChanged: function(newValue, oldValue) {
                this.fire('propertyChanged', {
                    prop: 'displayName',
                    oldValue: oldValue,
                    newValue: newValue
                });
            }
        });

    }());
    </script>
</dom-module>
